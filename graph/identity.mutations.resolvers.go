package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"

	"github.com/ericls/imgdd/graph/model"
	"github.com/ericls/imgdd/identity"
)

// Authenticate is the resolver for the authenticate field.
func (r *mutationResolver) Authenticate(ctx context.Context, email string, password string, organizationID *string) (*model.ViewerResult, error) {
	if email == "" {
		return nil, fmt.Errorf("email is required")
	}
	user := r.IdentityRepo.GetUserByEmail(email)
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}
	if !identity.CheckPasswordByUserId(user.Id, password, r.IdentityRepo) {
		return nil, fmt.Errorf("password incorrect")
	}
	_, orgUser := r.IdentityRepo.GetOrganizationForUser(user.Id, *organizationID)
	if orgUser == nil {
		return nil, fmt.Errorf("organization not found")
	}
	r.LoginFn(ctx, user.Id, orgUser.Id)
	return &model.ViewerResult{Viewer: &model.Viewer{}}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model.ViewerResult, error) {
	r.LogoutFn(ctx)
	return &model.ViewerResult{Viewer: &model.Viewer{}}, nil
}

// CreateUserWithOrganization is the resolver for the createUserWithOrganization field.
func (r *mutationResolver) CreateUserWithOrganization(ctx context.Context, input model.CreateUserWithOrganizationInput) (*model.ViewerResult, error) {
	if !r.AllowNewUser {
		return nil, fmt.Errorf("new user creation is disabled")
	}
	if input.UserEmail == "" {
		return nil, fmt.Errorf("user email is required")
	}
	orgName := input.OrganizationName
	if orgName == "" {
		orgName = input.UserEmail + "'s organization"
	}
	orgUser, err := r.IdentityRepo.CreateUserWithOrganization(
		input.UserEmail,
		orgName,
		input.UserPassword,
	)
	if err != nil {
		return nil, err
	}
	r.LoginFn(ctx, orgUser.User.Id, orgUser.Id)
	return &model.ViewerResult{Viewer: &model.Viewer{}}, nil
}

// SendResetPasswordEmail is the resolver for the sendResetPasswordEmail field.
func (r *mutationResolver) SendResetPasswordEmail(ctx context.Context, input model.SendResetPasswordEmailInput) (*model.SendResetPasswordEmailResult, error) {
	inputEmail := input.Email
	if inputEmail == "" {
		return nil, fmt.Errorf("email is required")
	}
	// This should always be true.
	success := true
	resp := &model.SendResetPasswordEmailResult{Success: success}
	user := r.IdentityRepo.GetUserByEmail(inputEmail)
	if user == nil {
		return resp, nil
	}
	err := identity.SendResetPasswordEmail(r.GetEmailBackend(ctx), r.SecretKey, user, r.IdentityRepo, r.GetBaseURL(ctx))
	if err != nil {
		resolverLogger.Err(err).Msg("failed to send reset password email")
	}
	return resp, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResult, error) {
	message := input.Message
	newPassword := input.Password
	if message == "" {
		return nil, fmt.Errorf("message is required")
	}
	err := identity.ResetPassword(r.IdentityRepo, r.SecretKey, message, newPassword)
	if err != nil {
		resolverLogger.Err(err).Msg("failed to reset password")
		return &model.ResetPasswordResult{Success: false}, nil
	}
	return &model.ResetPasswordResult{Success: true}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
